分布式事务

	1.分布式事务中间件其本身并不创建事务，而是基于对本地事务的协调从而达到事务一致性的效果。典型代表有：阿里的GTS（https://www.aliyun.com/aliware/txc）、开源应用LCN。

	a. 在设计框架之初的1.0 ~ 2.0的版本时，框架设计的步骤是如下的，各取其首字母得来的LCN命名。锁定事务单元（lock）、确认事务模块状态(confirm)、通知事务(notify)

	b. 创建事务组：是指在事务发起方开始执行业务代码之前先调用TxManager创建事务组对象，然后拿到事务标示GroupId的过程。

	c. 添加事务组：添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息添加通知给TxManager的操作。

	d. 关闭事务组：是指在发起方执行完业务代码以后，将发起方执行结果状态通知给TxManager的动作。当执行完关闭事务组的方法以后，TxManager将根据事务组信息来通知相应的参与模块提交或回滚事务

	@Override
	@TxTransaction(isStart = true)
	@Transactional
	public int save() {

	}

	其中 @TxTransaction(isStart = true) 为lcn 事务控制注解，其中isStart = true 表示该方法是事务的发起方例如，服务A 需要调用服务B,服务B 需要调用服务C，此时 服务A为服务发起方，其余为参与方，参与方只需@TxTransaction 即可


	订单服务为事务发起方，会在开始执行业务代码之前先调用TxManager创建事务组对象，然后拿到事务标示GroupId

	当订单服务调用rpc远程调用支付服务之前（类似于图中发起方请求模块A），lcn会拦截请求，并将groupId放入到请求头中

	当请求到达支付服务之前，请求会被拦截，判断请求头中是否含有groupId，如果有则是参与方，并且根据GroupId注册到TxManage的同一个事务组中

	支付服务在执行业务代码之前，lcn会代理其数据源

	支付服务和商品服务会在执行完业务方法以后，由于数据源被代理，本地事务不会立即提交。而是被代理假关闭

	当订单服务业务执行完毕，并且提交本地事务，会将本地事务的结果通知给TxManager

	TxManager去遍历事务组，取出其中的事务单元，并进行一一通知。

	参与方接收到通知以后，再进行相应的事务提交或者回滚操作，保持数据的一致性
